> Это черновик и я не советую его читать, т.к. я сам до конца не сформировал мнение
> см. ссылки внизу по теме

Если используешь ORM, тебе не нужны связи foreign keys в БД. Это плохая практика и вот почему.

Начнем издалека. У нас есть ACID. Буква C отвечает за консистентность. В БД'шках есть некоторые consistency для поддержания буковки C, однако обычно подчеркивается, что полная реализация C лежит на программе, работающей с этой бд.

> По бизнесу возраст должен быть от 18 до 60
> В бд мы задаем age тип integer
> в коде мы пишем условие age >=18 && age <=18

Соответственно, тут мы не полагаемся на базу, как источник знаний о конечном формате наших данных. Это прописано в коде.

Что происходит, когда мы используем ORM'ку и миграции и хотим указать foreign key?

> product.user_id === user.id

Мы пишем это правило в миграции:

```php
// File: product_migration.php
$table->foreign('user_id', 'fk_user_user_id')->references('id')->on('user');
```

А так же не забываем прописать зависимость в модели:

```php
// File: Product.php
public function user(): BelongsTo
{
    return $this->belongsTo(User::class, 'id');
}
```

Хочу обратить внимание, что с какой-то стороны, мы не прописываем ограничения и в бд и в коде. Мы прописываем их только в коде. Два раза. То есть дублируем код. И тут есть стандартный минус при нарушении DRY. Нам теперь постоянно нужно следить за двумя зайцами. И если мы поменяем в одном месте и не поменяем в другом - будут проблемы. Усложняется поддержка кодовой базы.

foreign key не дает никакого прироста производительности. Собранный orm'кой запрос будет выполняться так-же.

Минус не прописывать связи в бд - их не будет видно по построенной диаграмме с существующей базы данных. А диаграмма моделей все же немножко не то

[Дополнительные аргументы](https://planetscale.com/docs/learn/operating-without-foreign-key-constraints)
[Профанский видос на ютубе](https://www.youtube.com/watch?v=ttctyDDPtQU), но есть интересные комменты
